///////////////////////////////////////////////////////////////////////////////
//
// This file was automatically generated by RANOREX.
// Your custom recording code should go in this file.
// The designer will only add methods to this file, so your custom code won't be overwritten.
// http://www.ranorex.com
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Drawing;
using System.Threading;
using WinForms = System.Windows.Forms;

using Ranorex;
using Ranorex.Core;
using Ranorex.Core.Repository;
using Ranorex.Core.Testing;

using System.Diagnostics;

namespace project_1
{
	public partial class psexec_handler
	{
		/// <summary>
		/// This method gets called right after the recording has been started.
		/// It can be used to execute recording specific initialization code.
		/// </summary>
		private void Init()
		{
			// Your recording specific initialization code goes here.
		}

		public string get_cmd_remote(string serverName, string username, string password, string domain, string command)
		{
			/*
			 * PsExec.exe \\vagrant-1 -u vagrant -p vagrant powershell -command "Get-CimInstance Win32_Process -Filter \"name = 'explorer.exe'\" | select CommandLine"
			 */
			
			try
			{
				System.Diagnostics.Process process = new System.Diagnostics.Process();
				System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();
				startInfo.RedirectStandardOutput = true;
				startInfo.UseShellExecute = false;
				startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
				startInfo.FileName = "psexec.exe";
				if (null != username)
				{
					if (domain != "")
					{
						Ranorex.Report.Failure("no domain");
						startInfo.Arguments =  "";
					}
					else
					{
						Ranorex.Report.Info("with user");
						startInfo.Arguments = "\\\\BW-SERVER1 -u Administrator -p robert.123 powershell -command \"Get-WMIObject –Class Win32_Bios | Select PSComputername, __Server\"";
					}
				}
				else
				{
					//startInfo.Arguments = "PsExec.exe \\vagrant-1 -u vagrant -p vagrant powershell -command \"Get-CimInstance Win32_Process -Filter \"name = 'explorer.exe'\" | select CommandLine\"";
				}
				process.StartInfo = startInfo;
				process.Start();
				process.WaitForExit();

				if (process.ExitCode == 0 && null != process && process.HasExited)
				{
					Ranorex.Report.Info("result:" + process.StandardOutput.ReadToEnd());
					return process.StandardOutput.ReadToEnd();
				}
				else
				{
					Ranorex.Report.Info("errorrrrrrr" + process.StandardError.ToString());
					return "Error running the command : "+command;
				}
			}
			catch (Exception ex)
			{
				throw ex;
			}
			
		}

		public void psexec_2()
		{
			System.Diagnostics.Process process = new System.Diagnostics.Process();
			System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();
			startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
			startInfo.FileName = "cmd.exe"; 
				startInfo.Arguments = "PsExec.exe \\vagrant-1 -u vagrant -p vagrant powershell -command \"Get-CimInstance Win32_Process -Filter \"name = 'explorer.exe'\" | select CommandLine\"";
			process.StartInfo = startInfo;
			process.Start();
		}

        public void psexec_3()
        {
            Process p = new Process();
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = true;
            p.StartInfo.RedirectStandardInput = true;
            p.StartInfo.FileName = @"PsExec.exe";
            //p.StartInfo.Arguments = "\\\\vagrant-1 -u vagrant -p vagrant powershell -command \"Get-WMIObject –Class Win32_Bios | Select PSComputername, __Server\"";
            p.StartInfo.Arguments = @"\\BW_Server1 -accepteula -d c:\windows\system32\notepad.exe";
            p.Start();

            string output = p.StandardOutput.ReadToEnd();
            string errormessage = p.StandardError.ReadToEnd();

            p.WaitForExit();
        }
		


	}
}
